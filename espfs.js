"use strict";

//------------------------------------------------------------------------------

Object.defineProperty(exports, "__esModule", { value: true });

//------------------------------------------------------------------------------

const childProcess = require("child_process");
const fs = require("fs");
const os = require("os");
const path = require("path");
const process = require("process");
const tmp = require("tmp");
const vscode = require("vscode");
const WinReg = require("winreg");

//==============================================================================
// #region Constants

// --- VSCode Arduino Extension ---

const ARDUINO_CONFIG_FILE = path.join(".vscode", "arduino.json");

const PYTHON_PYTHONPATH = "python.pythonPath";                   // Python Executable

// --- new items ---

const ESPFS_DATA_FILES = "espfs.dataFiles";       // Location of SPIFFS files
const ESPFS_PREFERENCES = "espfs.preferencesPath"; // Location of Arduino Preferences and Packages
const ESPFS_ARDUINO_USER_PATH = "espfs.arduinoUserPath"; // Location of Ardiuno User Libraries
const ESPFS_SPIFFS_IMAGE = "espfs.spiffsImage";     // Packed SPIFFS file
const ESPFS_LITTLEFS_IMAGE = "espfs.littlefsImage";   // Packed LITTLEFS file
const ESPFS_LOGLEVEL = "espfs.logLevel";        // Level of spew generated by this extension

const ESPFS_MKSPIFFS_EXECUTABLE = "espfs.mkspiffs.executable"; // MKSPIFFS Executable
const ESPFS_MKSPIFFS_DEBUG_LEVEL = "espfs.mkspiffs.debugLevel"; // Value passed to MKSPIFFS Executable
const ESPFS_MKSPIFFS_ALL_FILES = "espfs.mkspiffs.allFiles";   // Value passed to MKSPIFFS Executable

const ESPFS_MKLITTLEFS_EXECUTABLE = "espfs.mklittlefs.executable"; // MKSPIFFS Executable
const ESPFS_MKLITTLEFS_DEBUG_LEVEL = "espfs.mklittlefs.debugLevel"; // Value passed to MKSPIFFS Executable
const ESPFS_MKLITTLEFS_ALL_FILES = "espfs.mklittlefs.allFiles";   // Value passed to MKSPIFFS Executable

const ESPFS_ESPTOOL_EXECUTABLE = "espfs.esptool.executable"; // ESPTOOL Executable
const ESPFS_ESPTOOL_VERBOSITY = "espfs.esptool.verbosity";  // Value passed to ESPTOOL Executable

const ESPFS_ESPTOOL_PY_BEFORE = "espfs.esptool.before";         // Value passed to ESPTOOL.PY script
const ESPFS_ESPTOOL_PY_AFTER = "espfs.esptool.after";          // Value passed to ESPTOOL.PY script
const ESPFS_ESPTOOL_PY_NO_STUB = "espfs.esptool.no_stub";        // Value passed to ESPTOOL.PY script
const ESPFS_ESPTOOL_PY_TRACE = "espfs.esptool.trace";          // Value passed to ESPTOOL.PY script
const ESPFS_ESPTOOL_PY_SPI = "espfs.esptool.spi_connection"; // Value passed to ESPTOOL.PY script
const ESPFS_ESPTOOL_PY_COMPRESS = "espfs.esptool.compress";       // Value passed to ESPTOOL.PY script
const ESPFS_ESPTOOL_PY_VERIFY = "espfs.esptool.verify";         // Value passed to ESPTOOL.PY script

const ESPFS_ESPOTA_PY = "espfs.espota.py";        // EspOTA Python script
const ESPFS_ESPOTA_ESP_PORT = "espfs.espota.esp.port";  // IP Port for ESP8266
const ESPFS_ESPOTA_HOST_IP = "espfs.espota.host.ip";   // IP Address for Host
const ESPFS_ESPOTA_HOST_PORT = "espfs.espota.host.port"; // IP Port for Host
const ESPFS_ESPOTA_AUTH = "espfs.espota.auth";      // Authentication password for espota.py
const ESPFS_ESPOTA_DEBUG = "espfs.espota.debug";     // Enable debug output from espota.py

// #endregion

//==============================================================================
// #region Logging

const RESET = "\u001b[0m";
const BOLD = "\u001b[1m";

const RED = "\u001b[31m";
const GREEN = "\u001b[32m";
const YELLOW = "\u001b[33m";
const BLUE = "\u001b[34m";
const MAGENTA = "\u001b[35m";
const CYAN = "\u001b[36m";

const BOLD_RED = "\u001b[31;1m";

//------------------------------------------------------------------------------

let outputChannel = null;
let logLevel = "normal"; // "normal", "verbose", "silent", "debug"

function log(message, color) {
    if (logLevel === "silent")
        return;

    if (color)
        console.log(`${color}${message}${RESET}`);
    else
        console.log(message);

    outputChannel.appendLine(message.replace(/\x1b\[[\d|\;]{1,4}m/g, ""));
    outputChannel.show();
}

//------------------------------------------------------------------------------

function logAnnounce(message) { log(message, GREEN); }
function logUrgent(message) { log(message, BOLD_RED); }
function logImportant(message) { log(message, RED); }
function logCommand(message) { log(message, YELLOW); }
function logSpiffs(message) { log(`  [SPIFFS] ${message}`, BLUE); }
function logLittlefs(message) { log(`  [LITTLEFS] ${message}`, BLUE); }

//------------------------------------------------------------------------------

function logVerbose(message) {
    if (logLevel === "verbose" || logLevel === "debug")
        log(message, MAGENTA);
}

//------------------------------------------------------------------------------

function logDebug(message) {
    if (logLevel === "debug")
        log(message, CYAN);
}

//------------------------------------------------------------------------------

function showErrorMessage(message) {
    const dismiss = { isCloseAffordance: true, title: "Dismiss" };

    vscode.window.showErrorMessage(message, dismiss);
}

//------------------------------------------------------------------------------

function showWarningMessage(message) {
    vscode.window.showWarningMessage(message);
}

//------------------------------------------------------------------------------

function showInformationMessage(message) {
    vscode.window.showInformationMessage(message);
}

// #endregion

//==============================================================================
// #region Helper functions

function stringToInt(value) {
    return parseInt(value, value.match(/^0x/i) ? 16 : 10);
}

//------------------------------------------------------------------------------

function toHex(decimal, width = 4) {
    return ("0".repeat(width) + (Number(decimal).toString(16))).slice(-width).toUpperCase();
}

//------------------------------------------------------------------------------

function makeOsPath(dir) {
    dir = dir.replace(/\\/g, "/");

    if (dir.indexOf(" ") != -1)
        dir = `"${dir}"`;

    return dir;
}

// #endregion

//==============================================================================
// #region Utility functions

function getVscodeConfigValue(key) {
    return vscode.workspace.getConfiguration().get(key);
}

//------------------------------------------------------------------------------

function getOS() { return os.platform(); }

//------------------------------------------------------------------------------

function program(name) {
    return (getOS() === "win32" && name.indexOf(".") == -1)
        ? (name + ".exe")
        : name;
}

//------------------------------------------------------------------------------

function runCommand(command, args) {
    logVerbose("Running: " + command + " " + args.join(" "));

    const spawn = childProcess.spawnSync(command, args, { encoding: "utf8" });

    if (spawn.error)
        throw spawn.error;

    spawn.stdout
        .toString()
        .replace(/\r\n/, "\n")
        .split("\n")
        .forEach(line => logCommand(line.trimRight()));

    spawn.stderr
        .toString()
        .replace(/\r\n/, "\n")
        .split("\n")
        .forEach(line => logUrgent(line.trimRight()));

    if (spawn.status)
        throw `${command} returned ${spawn.status}`;

    return spawn.stdout.toString();
}

//-------------------------------------------------------------------------------

function getTempPath() {
    const temp = tmp.dirSync();

    logDebug(`System tmp path: "${temp}"`);

    return temp;
}

//------------------------------------------------------------------------------

function dirExists(dir) {
    try {
        return fs.statSync(dir).isDirectory();
    }
    catch (e) {
        return false;
    }
}

//------------------------------------------------------------------------------

function getFolders(dir) {
    return fs.readdirSync(dir);
}

//------------------------------------------------------------------------------

function fileExists(file) {
    try {
        return fs.statSync(file).isFile();
    }
    catch (e) {
        return false;
    }
}

//------------------------------------------------------------------------------

function readFile(name) {
    return fs.readFileSync(name, "utf8");
}

//------------------------------------------------------------------------------

function readLines(name) {
    return readFile(name).split(/[\r\n|\r|\n]/);
}

//------------------------------------------------------------------------------

function JSONify(obj) {
    return JSON.stringify(obj, null, " ");
}

//------------------------------------------------------------------------------

function getRegistryValue(hive, key, name) {
    return new Promise((resolve, reject) => {
        try {
            const regKey = new WinReg({
                hive,
                key,
            });

            regKey.valueExists(name, (e, exists) => {
                if (e) {
                    reject(e);
                }

                if (exists) {
                    regKey.get(name, (err, result) => {
                        if (!err) {
                            resolve(result ? result.value : "");
                        } else {
                            reject(err);
                        }
                    });
                } else {
                    resolve("");
                }
            });
        } catch (error) {
            reject(error);
        }
    });
}

// #endregion

//==============================================================================
// #region ESPFS Specific code
//==============================================================================

function getPreferencesPath() {
    let dir = getVscodeConfigValue(ESPFS_PREFERENCES);

    if (!dir) {
        switch (getOS()) {
            case "win32":
                dir = path.join(process.env.LOCALAPPDATA, "Arduino15");
                break;

            case "linux":
                dir = path.join(process.env.HOME, ".arduino15");
                break;

            case "darwin":
                dir = path.join(process.env.HOME, "Library/Arduino15");
                break;
        }
    }

    if (!dir)
        throw `Can't find preferences path.`;

    dir = path.resolve(dir);

    if (!dirExists(dir))
        throw `Preferences path "${dir}" doesn't exist.`;

    logVerbose(`Preferences Path: "${dir}"`);
    return dir;
}

//-------------------------------------------------------------------------------

function getArduinoUserPath() {
    let dir = getVscodeConfigValue(ESPFS_ARDUINO_USER_PATH);

    if (!dir) {
        switch (getOS()) {
            case "win32":
                dir = path.join(process.env.USERPROFILE, "Documents", "Arduino");
                break;

            case "linux":
                dir = path.join(process.env.HOME, "Arduino");
                break;

            case "darwin":
                dir = path.join(process.env.HOME, "Documents", "Arduino");
                break;
        }
    }

    if (!dir)
        throw `Can't find arduino user path.`;

    dir = path.resolve(dir);

    if (!dirExists(dir))
        throw `Preferences path "${dir}" doesn't exist.`;

    logVerbose(`Arduino User Path: "${dir}"`);
    return dir;
}

//-------------------------------------------------------------------------------

function getDataFilesPath(arduinoJson) {
    let dir = getVscodeConfigValue(ESPFS_DATA_FILES) || "./data";

    if (dir.startsWith("."))
        dir = path.join(vscode.workspace.rootPath, dir);

    dir = path.resolve(dir);

    if (!dirExists(dir))
        throw `ESP8266 Data Files path "${dir}" not found.`;

    logVerbose(`ESP8266 Data Files path: "${dir}"`);

    return dir;
}

//-------------------------------------------------------------------------------

function getSpiffsImage() {
    let file = getVscodeConfigValue(ESPFS_SPIFFS_IMAGE)
        || path.join(getTempPath(), "./spiffs.bin");

    if (file.startsWith("."))
        file = path.join(vscode.workspace.rootPath, file);

    file = path.resolve(file);

    logVerbose(`SPIFFS Image: "${file}"`);
    return file;
}

function getLittlefsImage() {
    let file = getVscodeConfigValue(ESPFS_LITTLEFS_IMAGE)
        || path.join(getTempPath(), "./mklittlefs.bin");

    if (file.startsWith("."))
        file = path.join(vscode.workspace.rootPath, file);

    file = path.resolve(file);

    logVerbose(`LITTLEFS Image: "${file}"`);
    return file;
}

//-------------------------------------------------------------------------------

async function getArduinoPreferences(preferencesPath) {
    const preferences = {};

    const file = path.join(preferencesPath, "preferences.txt");
    logVerbose(`Reading preferences from "${file}"`);

    readLines(file)
        .forEach(line => {
            if (line.startsWith("#") || line.length == 0)
                return;

            const pair = line.split("=");

            logDebug(`  "${pair[0]}"="${pair[1]}"`);
            preferences[pair[0]] = pair[1];
        }
        );

    return preferences;
}

//-------------------------------------------------------------------------------

async function getArduinoJson() {
    var json = JSON.parse(readFile(path.join(vscode.workspace.rootPath, ARDUINO_CONFIG_FILE)));

    // Split the configuration settings into key/values

    if (json.configuration) {
        json.configuration.split(",").forEach(config => {
            let param = config.split("=");

            json[param[0]] = param[1];
        });
    }

    logDebug(`arduinoJson:`);
    JSONify(json).split("\n").map(line => logDebug(line));

    return json;
}
//-------------------------------------------------------------------------------

function _getTarget(arduinJson, preferences) {
    if (!arduinJson.board) {
        const target =
        {
            package: preferences["target_package"],
            architecture: preferences["target_platform"],
            board: preferences["board"]
        };

        return target;
    }
    const values = arduinJson.board.split(":");

    const target =
    {
        package: values[0],
        architecture: values[1],
        board: values[2]
    };

    return target;
}

//------------------------------------------------------------------------------

function getPreference(arduinoJson, preferences, index, defval) {

    if (arduinoJson.hasOwnProperty(index))
        return arduinoJson[index];

    const value = preferences["custom_" + index];

    if (!value) {
        if (defval != undefined) {
            return defval;
        } else {
            throw `Can't determine ${index}.`;
        }
    }

    const match = value.match(/^(${target.board}|generic)_(\S+)/);

    return match ? match[2] : "";
}

//------------------------------------------------------------------------------

function getTarget(arduinoJson, preferences) {

    const target = _getTarget(arduinoJson, preferences);

    if (!["esp8266", "esp32"].includes(target.architecture))
        throw `Current Arduino package/architecture is not ESP8266 or ESP32.`;

    target.flashSize = getPreference(arduinoJson, preferences, "eesz", "detect");
    target.flashMode = getPreference(arduinoJson, preferences, "FlashMode", "keep");
    target.flashFreq = getPreference(arduinoJson, preferences, "FlashFreq", "keep");

    logDebug(`target:`);
    JSONify(target).split("\n").map(line => logDebug(line));

    return target;
}

//------------------------------------------------------------------------------

function getEspPackagePath(arduinoUserPath, preferencesPath, target) {

    switch (target.architecture) {
        case "esp8266": {
            const dir = path.join(preferencesPath, "packages", target.package, "hardware", target.architecture);

            if (!dirExists(dir))
                throw `ESP8266 has not been installed with the Arduino Board Manager (ESPpackagepath). ${dir}`;

            const folders = getFolders(dir);

            if (folders.length != 1)
                throw `There should only be one ESP8266 Package installed with the Arduino Board Manager.`;

            const esp8266Path = path.join(dir, folders[0]);
            logImportant(`Found ESP8266 packages: ${esp8266Path}`);

            return esp8266Path;
        }

        case "esp32": {
            // const esp32Path = path.join(arduinoUserPath, "hardware", target.package, target.architecture);
            const dir = path.join(preferencesPath, "packages", target.package, "hardware", target.architecture);
            if (!dirExists(dir))
                throw `ESP32 has not been installed correctly - see https://github.com/espressif/arduino-esp32. ` + dir;

            const folders = getFolders(dir);

            if (folders.length != 1)
                throw `There should only be one ESP32 Package installed with the Arduino Board Manager.`;

            const esp32Path = path.join(dir, folders[0]);

            logImportant(`Found ESP32 packages: ${esp32Path}`);

            return esp32Path;
        }
    }
}

//------------------------------------------------------------------------------

function getSpiffsPartition(packagesPath, partition) {
    var data = {};

    readLines(path.join(packagesPath, "tools", "partitions", partition + ".csv"))
        .forEach(line => {
            const values = line.split(",");

            data[values[0]] = {
                "type": (values[1] || "").trim(),
                "subType": (values[2] || "").trim(),
                "offset": (values[3] || "").trim(),
                "size": (values[4] || "").trim(),
                "flags": (values[5] || "").trim()
            };
        }
        );

    return data;
}

//------------------------------------------------------------------------------

function getSpiffsOptions(packagesPath, target, arduinoJson, preferences) {
    const spiffsOptions = {};

    readLines(path.join(packagesPath, "boards.txt"))
        .forEach(line => {
            const match = line.match(`${target.board}\\.(?:build|upload)\\.(\\S+)=(\\S+)`)
                || line.match(`${target.board}\\.menu\\.eesz\\.${target.flashSize}\\.(?:build|upload)\\.(\\S+)=(\\S+)`)
                || line.match(`${target.board}\\.menu\\.PartitionScheme\\.${arduinoJson.PartitionScheme}\\.(?:build|upload)\\.(\\S+)=(\\S+)`);

            if (match)
                spiffsOptions[match[1]] = match[2];
        }
        );

    switch (target.architecture) {
        case "esp8266": {
            if (!spiffsOptions.spiffs_start)
                throw `Missing "spiffs_start" definition: target = ${target.architecture}, config = ${target.memoryConfig}.`;

            if (!spiffsOptions.spiffs_end)
                throw `Missing "spiffs_end" definition: target = ${target.architecture}, config = ${target.memoryConfig}.`;

            spiffsOptions.dataSize = (stringToInt(spiffsOptions.spiffs_end) - stringToInt(spiffsOptions.spiffs_start)).toString();
        }
            break;

        case "esp32": {
            if (!spiffsOptions.partitions)
                throw `Missing "partitions" definition: target = ${target}, config = ${arduinoJson.PartitionScheme}.`;

            const partition = getSpiffsPartition(packagesPath, spiffsOptions.partitions);

            spiffsOptions.spiffs_start = partition.spiffs.offset;
            spiffsOptions.dataSize = partition.spiffs.size;
        }
            break;
    }

    spiffsOptions.flashMode = preferences.flash_mode;
    spiffsOptions.flashFreq = preferences.flash_freq;
    spiffsOptions.flashSize = "0x" + toHex(stringToInt(spiffsOptions.spiffs_start) + stringToInt(spiffsOptions.dataSize));

    if (arduinoJson.baud)
        spiffsOptions.speed = arduinoJson.baud;

    if (arduinoJson.ResetMethod)
        spiffsOptions.resetmethod = arduinoJson.ResetMethod;

    logDebug(`spiffs:`);
    JSONify(spiffsOptions).split("\n").map(line => logDebug(line));

    return spiffsOptions;
}


function getLittlefsPartition(packagesPath, partition) {
    var data = {};

    readLines(path.join(packagesPath, "tools", "partitions", partition + ".csv"))
        .forEach(line => {
            const values = line.split(",");

            data[values[0]] = {
                "type": (values[1] || "").trim(),
                "subType": (values[2] || "").trim(),
                "offset": (values[3] || "").trim(),
                "size": (values[4] || "").trim(),
                "flags": (values[5] || "").trim()
            };
        }
        );

    return data;
}

//------------------------------------------------------------------------------

function getLittlefsOptions(packagesPath, target, arduinoJson, preferences) {
    const littlefsOptions = {};

    readLines(path.join(packagesPath, "boards.txt"))
        .forEach(line => {
            const match = line.match(`${target.board}\\.(?:build|upload)\\.(\\S+)=(\\S+)`)
                || line.match(`${target.board}\\.menu\\.eesz\\.${target.flashSize}\\.(?:build|upload)\\.(\\S+)=(\\S+)`)
                || line.match(`${target.board}\\.menu\\.PartitionScheme\\.${arduinoJson.PartitionScheme}\\.(?:build|upload)\\.(\\S+)=(\\S+)`);

            if (match)
                littlefsOptions[match[1]] = match[2];
        }
        );

    switch (target.architecture) {
        case "esp8266": {
            if (!littlefsOptions.spiffs_start)
                throw `Missing "spiffs_start" definition: target = ${target.architecture}, config = ${target.memoryConfig}.`;

            if (!littlefsOptions.spiffs_end)
                throw `Missing "spiffs_end" definition: target = ${target.architecture}, config = ${target.memoryConfig}.`;

            littlefsOptions.dataSize = (stringToInt(littlefsOptions.spiffs_end) - stringToInt(littlefsOptions.spiffs_start)).toString();
        }
            break;

        case "esp32": {
            if (!littlefsOptions.partitions)
                throw `Missing "partitions" definition: target = ${target}, config = ${arduinoJson.PartitionScheme}.`;

            const partition = getLittlefsPartition(packagesPath, littlefsOptions.partitions);

            littlefsOptions.spiffs_start = partition.spiffs.offset;
            littlefsOptions.dataSize = partition.spiffs.size;
        }
            break;
    }

    littlefsOptions.flashMode = preferences.flash_mode;
    littlefsOptions.flashFreq = preferences.flash_freq;
    littlefsOptions.flashSize = "0x" + toHex(stringToInt(littlefsOptions.spiffs_start) + stringToInt(littlefsOptions.dataSize));

    if (arduinoJson.baud)
        littlefsOptions.speed = arduinoJson.baud;

    if (arduinoJson.ResetMethod)
        littlefsOptions.resetmethod = arduinoJson.ResetMethod;

    logDebug(`littlefs1:`);
    JSONify(littlefsOptions).split("\n").map(line => logDebug(line));

    return littlefsOptions;
}

//------------------------------------------------------------------------------

function getEspToolsPath(arduinoUserPath, preferencesPath, target) {

    const dir = target.architecture == "esp8266"
        ? path.resolve(path.join(preferencesPath, "packages", target.architecture, "tools"))
        //: path.resolve(path.join(arduinoUserPath, "hardware", target.package, target.architecture, "tools"));
        //: path.resolve(path.join(preferencesPath, "packages", target.architecture, "hardware", "tools"));
        // : path.resolve(path.join(preferencesPath, "packages", target.package, "tools"));
        : path.resolve(path.join(preferencesPath, "packages", target.architecture, "tools"))

    if (!dirExists(dir))
        throw `Can't find tools path. ` + dir;

    logVerbose(`Tools Path: "${dir}"`);
    return dir;
}

//------------------------------------------------------------------------------

function getPythonExecutable() {
    const python = getVscodeConfigValue(PYTHON_PYTHONPATH) || "python";

    logVerbose(`Python Executable: "${python}"`);
    return python;
}

//------------------------------------------------------------------------------

function getEspotaPy(packagePath) {
    const file = getVscodeConfigValue(ESPFS_ESPOTA_PY) || path.join(packagePath, "tools", "espota.py");

    if (!fileExists(file))
        throw `Can't find ${file}.`;

    logVerbose(`espota.py: ${CYAN}${file}`);
    return file;
}

//------------------------------------------------------------------------------

function getPort(arduinoJson, preferences) {
    let port = arduinoJson.port || preferences["serial.port"];

    logVerbose(`Output Port: ${port}`);
    return port;
}

//------------------------------------------------------------------------------

function isIP(port) {
    return port.match(/^(\d+)\.(\d+).(\d+).(\d+)(:\d+)?$/);
}

// #endregion

//==============================================================================
// #region MKSPIFFS

function getMkSpiffs(target, espToolsPath) {
    const configFile = getVscodeConfigValue(ESPFS_MKSPIFFS_EXECUTABLE);

    if (configFile) {
        if (!fileExists(configFile))
            throw `Can't locate ${configFile}.`;

        logVerbose(`mkspiffs: ${CYAN}${configFile}`);
        logImportant(`Found "mkspiffs" via VSCode Configuration`);

        return configFile;
    }

    switch (target.architecture) {
        case "esp8266": {
            const folders = getFolders(path.join(espToolsPath, "mkspiffs"));

            if (folders.length != 1)
                throw `"${target.architecture}" not installed correctly through Arduino Board Manager`;

            const mkspiffs = path.join(espToolsPath, "mkspiffs", folders[0], program("mkspiffs"));

            if (!fileExists(mkspiffs))
                throw `"Can't locate "${mkspiffs}"`;

            return mkspiffs;
        }

        case "esp32": {
            const mkspiffs = path.join(espToolsPath, "mkspiffs", program("mkspiffs"));

            if (!fileExists(mkspiffs))
                throw `"Can't locate "${mkspiffs}"`;

            return mkspiffs;
        }
    }
}

//------------------------------------------------------------------------------

function makeMkspiffsArgs(args) {
    const allFiles = getVscodeConfigValue(ESPFS_MKSPIFFS_ALL_FILES);

    if (allFiles)
        args.unshift("--all-files", allFiles);

    const debug = getVscodeConfigValue(ESPFS_MKSPIFFS_DEBUG_LEVEL);

    if (debug)
        args.unshift("--debug", debug);

    return args;
}

//------------------------------------------------------------------------------

function packSpiffs(mkspiffs, dataPath, spiffsOptions, spiffsImage) {
    log(`--- Packing SPIFFS file ---`);

    const dataSize = spiffsOptions.dataSize;
    const dataSizeInK = (dataSize >> 10) + 1;
    const spiPage = stringToInt(spiffsOptions.spiffs_pagesize || "256");
    const spiBlock = stringToInt(spiffsOptions.spiffs_blocksize || "4096");

    logImportant(`SPIFFS Creating Image... (${spiffsImage})`);
    logSpiffs(`program: ${mkspiffs}`);
    logSpiffs(`data   : ${dataPath}`);
    logSpiffs(`size   : ${dataSizeInK}K`);
    logSpiffs(`page   : ${spiPage}`);
    logSpiffs(`block  : ${spiBlock}`);

    runCommand(
        makeOsPath(mkspiffs),
        makeMkspiffsArgs([
            "--create", makeOsPath(dataPath),
            "--size", dataSize,
            "--page", spiPage,
            "--block", spiBlock,
            makeOsPath(spiffsImage)
        ])
    );
}

//------------------------------------------------------------------------------

/*function unpackSpiffs(mkspiffs, dataPath, spiffsOptions, spiffsImage) {
    log(`--- Unpacking SPIFFS file ---`);

    const dataSize = spiffsOptions.dataSize;
    const dataSizeInK = (dataSize >> 10) + 1;
    const spiPage = stringToInt(spiffsOptions.spiffs_pagesize || "256");
    const spiBlock = stringToInt(spiffsOptions.spiffs_blocksize || "4096");

    logImportant(`SPIFFS Unpacking Image... (${spiffsImage})`);
    logSpiffs(`program: ${mkspiffs}`);
    logSpiffs(`data   : ${dataPath}`);
    logSpiffs(`size   : ${dataSizeInK}K`);
    logSpiffs(`page   : ${spiPage}`);
    logSpiffs(`block  : ${spiBlock}`);

    runCommand(
        makeOsPath(mkspiffs),
        makeMkspiffsArgs([
            "--unpack", makeOsPath(dataPath),
            "--size", dataSize,
            "--page", spiPage,
            "--block", spiBlock,
            makeOsPath(spiffsImage)
        ])
    );
}*/

//------------------------------------------------------------------------------

function listSpiffs(mkspiffs, spiffsOptions, spiffsImage) {
    log(`--- List SPIFFS file ---`);

    const spiPage = stringToInt(spiffsOptions.spiffs_pagesize || "256");
    const spiBlock = stringToInt(spiffsOptions.spiffs_blocksize || "4096");

    logImportant(`SPIFFS List Files... (${spiffsImage})`);
    logSpiffs(`program: ${mkspiffs}`);
    logSpiffs(`page   : ${spiPage}`);
    logSpiffs(`block  : ${spiBlock}`);

    runCommand(
        makeOsPath(mkspiffs),
        makeMkspiffsArgs([
            "--list",
            "--page", spiPage,
            "--block", spiBlock,
            makeOsPath(spiffsImage)
        ])
    );
}

// #endregion

//==============================================================================
// #region MKLITTLEFS

function getMkLittlefs(target, espToolsPath) {
    const configFile = getVscodeConfigValue(ESPFS_MKLITTLEFS_EXECUTABLE);

    if (configFile) {
        if (!fileExists(configFile))
            throw `Can't locate ${configFile}.`;

        logVerbose(`mklittlefs: ${CYAN}${configFile}`);
        logImportant(`Found "mklittlefs" via VSCode Configuration`);

        return configFile;
    }

    switch (target.architecture) {
        case "esp8266": {
            const folders = getFolders(path.join(espToolsPath, "mklittlefs"));

            if (folders.length != 1)
                throw `"${target.architecture}" not installed correctly through Arduino Board Manager`;

            const mklittlefs = path.join(espToolsPath, "mklittlefs", folders[0], program("mklittlefs"));

            if (!fileExists(mklittlefs))
                throw `"Can't locate "${mklittlefs}"`;

            return mklittlefs;
        }

        case "esp32": {
            const mklittlefs = path.join(espToolsPath, "mklittlefs", program("mklittlefs"));

            if (!fileExists(mklittlefs))
                throw `"Can't locate "${mklittlefs}"`;

            return mklittlefs;
        }
    }
}

//------------------------------------------------------------------------------

function makeMklittlefsArgs(args) {
    const allFiles = getVscodeConfigValue(ESPFS_MKLITTLEFS_ALL_FILES);

    if (allFiles)
        args.unshift("--all-files", allFiles);

    const debug = getVscodeConfigValue(ESPFS_MKLITTLEFS_DEBUG_LEVEL);

    if (debug)
        args.unshift("--debug", debug);

    return args;
}

//------------------------------------------------------------------------------

function packLittlefs(mklittlefs, dataPath, littlefsOptions, littlefsImage) {
    log(`--- Packing LITTLEFS file ---`);

    const dataSize = littlefsOptions.dataSize;
    const dataSizeInK = (dataSize >> 10) + 1;
    const spiPage = stringToInt(littlefsOptions.spiffs_pagesize || "256");
    const spiBlock = stringToInt(littlefsOptions.spiffs_blocksize || "4096");

    logImportant(`LITTLEFS Creating Image... (${littlefsImage})`);
    logLittlefs(`program: ${mklittlefs}`);
    logLittlefs(`data   : ${dataPath}`);
    logLittlefs(`size   : ${dataSize}`);
    logLittlefs(`size   : ${dataSizeInK}K`);
    logLittlefs(`page   : ${spiPage}`);
    logLittlefs(`block  : ${spiBlock}`);

    runCommand(
        makeOsPath(mklittlefs),
        makeMklittlefsArgs([
            "--create", makeOsPath(dataPath),
            "--size", dataSize,
            "--page", spiPage,
            "--block", spiBlock,
            makeOsPath(littlefsImage)
        ])
    );
}

//------------------------------------------------------------------------------

/*function unpackLittlefs(mklittlefs, dataPath, littlefsOptions, littlefsImage) {
    log(`--- Unpacking LITTLEFS file ---`);

    const dataSize = littlefsOptions.dataSize;
    const dataSizeInK = (dataSize >> 10) + 1;
    const spiPage = stringToInt(littlefsOptions.spiffs_pagesize || "256");
    const spiBlock = stringToInt(littlefsOptions.spiffs_blocksize || "4096");
	
    logImportant(`LITTLEFS Unpacking Image... (${littlefsImage})`);
    logLittlefs(`program: ${mklittlefs}`);
    logLittlefs(`data   : ${dataPath}`);
    logLittlefs(`size   : ${dataSizeInK}K`);
    logLittlefs(`page   : ${spiPage}`);
    logLittlefs(`block  : ${spiBlock}`);

    runCommand(
        makeOsPath(mklittlefs),
        makeMklittlefsArgs([
            "--unpack", makeOsPath(dataPath),
            "--size", dataSize,
            "--page", spiPage,
            "--block", spiBlock,
            makeOsPath(littlefsImage)
        ])
    );
}*/

//------------------------------------------------------------------------------

function listLittlefs(mklittlefs, littlefsOptions, littlefsImage) {
    log(`--- List LITTLEFS file ---`);

    const spiPage = stringToInt(littlefsOptions.spiffs_pagesize || "256");
    const spiBlock = stringToInt(littlefsOptions.spiffs_blocksize || "4096");

    logImportant(`LITTLEFS List Files... (${littlefsImage})`);
    logLittlefs(`program: ${mklittlefs}`);
    logLittlefs(`page   : ${spiPage}`);
    logLittlefs(`block  : ${spiBlock}`);

    runCommand(
        makeOsPath(mklittlefs),
        makeMklittlefsArgs([
            "--list",
            "--page", spiPage,
            "--block", spiBlock,
            makeOsPath(littlefsImage)
        ])
    );
}

// #endregion

//==============================================================================
// #region ESPTOOL

function getEspTool(target, espToolsPath) {
    const configFile = getVscodeConfigValue(ESPFS_ESPTOOL_EXECUTABLE);

    if (configFile) {
        if (!fileExists(configFile))
            throw `Can't locate ${configFile}.`;

        logVerbose(`esptool: ${CYAN}${configFile}`);
        logImportant(`Found "esptool" via VSCode Configuration`);

        return configFile;
    }

    switch (target.architecture) {
        case "esp8266": {
            const folders = getFolders(path.join(espToolsPath, "esptool"));

            if (folders.length != 1)
                throw `"${target.architecture}" not installed correctly through Arduino Board Manager`;

            const version = folders[0];

            const esptool = path.join(espToolsPath, "esptool", version, program("esptool"));

            if (!fileExists(esptool))
                throw `"Can't locate "${esptool}"`;

            logVerbose(`esptool (${version}): ${CYAN}${esptool}`);

            return esptool;
        }

        case "esp32": {
            const folders = getFolders(path.join(espToolsPath, "esptool"));

            if (folders.length != 1)
                throw `"${target.architecture}" not installed correctly through Arduino Board Manager`;

            const version = folders[0];

            const esptool = path.join(espToolsPath, "esptool", version, program("esptool"));

            if (!fileExists(esptool))
                throw `"Can't locate "${esptool}"`;

            logVerbose(`esptool (${version}): ${CYAN}${esptool}`);

            return esptool;
        }
    }
}

//------------------------------------------------------------------------------

// -ca <address>
// -cd <resetMethod>
// -cp <port>
// -cb <speed>
// -vvv

function _uploadSpiffsEspTool(esptool, commPort, spiffsImage, spiffsOptions) {
    log(`--- Uploading SPIFFS file with esptool[.exe] ---`);

    const uploadAddress = `0x` + toHex(stringToInt(spiffsOptions.spiffs_start), 6);
    const uploadSpeed = stringToInt(spiffsOptions.speed);
    const resetMethod = spiffsOptions.resetmethod;

    logImportant(`SPIFFS Uploading Image... (${spiffsImage})`);
    logSpiffs(`program: ${esptool}`);
    logSpiffs(`address: ${uploadAddress}`);
    logSpiffs(`reset  : ${resetMethod}`);
    logSpiffs(`port   : ${commPort}`);
    logSpiffs(`speed  : ${uploadSpeed}`);

    let args = [
        "-ca", uploadAddress,          // Address in flash.
        "-cd", resetMethod,            // Board reset method: "none", "ck", "nodemcu", or "wifio".
        "-cp", commPort,               // Serial Port (Default Linux: /dev/ttyUSB0, Windows: COM1, OSx: /dev/tty.usbserial).
        "-cb", uploadSpeed,            // Baud rate (Default: 115200).
        "-cf", makeOsPath(spiffsImage) // SPIFFS File
    ];

    const verbosity = getVscodeConfigValue(ESPFS_ESPTOOL_VERBOSITY);

    if (verbosity)
        args.unshift(`-${verbosity}`);

    runCommand(makeOsPath(esptool), args);
}

function _uploadLittlefsEspTool(esptool, commPort, littlefsImage, littlefsOptions) {
    log(`--- Uploading LITTLEFS !!! file with esptool[.exe] ---`);

    const uploadAddress = `0x` + toHex(stringToInt(littlefsOptions.spiffs_start), 6);
    const uploadSpeed = stringToInt(littlefsOptions.speed);
    const resetMethod = littlefsOptions.resetmethod;

    logImportant(`LITTLEFS Uploading Image... (${littlefsImage})`);
    logLittlefs(`program: ${esptool}`);
    logLittlefs(`address: ${uploadAddress}`);
    logLittlefs(`reset  : ${resetMethod}`);
    logLittlefs(`port   : ${commPort}`);
    logLittlefs(`speed  : ${uploadSpeed}`);

    let args = [
        "-ca", uploadAddress,          // Address in flash.
        "-cd", resetMethod,            // Board reset method: "none", "ck", "nodemcu", or "wifio".
        "-cp", commPort,               // Serial Port (Default Linux: /dev/ttyUSB0, Windows: COM1, OSx: /dev/tty.usbserial).
        "-cb", uploadSpeed,            // Baud rate (Default: 115200).
        "-cf", makeOsPath(littlefsImage) // LITTLEFS File
    ];

    const verbosity = getVscodeConfigValue(ESPFS_ESPTOOL_VERBOSITY);

    if (verbosity)
        args.unshift(`-${verbosity}`);

    runCommand(makeOsPath(esptool), args);
}

//------------------------------------------------------------------------------

// --chip auto,esp32,esp8266
// --baud <rate>
// --port <port>
// --before default_reset,no_reset
// --after hard_reset,soft_reset,no_reset
// --no_stub
// --trace
//  write_flash
// --compress
// --flash_mode <mode>
// --flash_freq <freq>
// --flash_size <size>
// --spi_connection <spi>
// --verify

function _uploadSpiffsEspToolPy(esptool, commPort, spiffsImage, spiffsOptions, target) {
    log(`--- Uploading SPIFFS file with esptool.py ---`);

    const python = getPythonExecutable();

    const uploadAddress = `0x` + toHex(stringToInt(spiffsOptions.spiffs_start), 6);
    const uploadSpeed = stringToInt(spiffsOptions.speed);
    const resetMethod = spiffsOptions.resetmethod;

    const before = getVscodeConfigValue(ESPFS_ESPTOOL_PY_BEFORE) || "default_reset";
    const after = getVscodeConfigValue(ESPFS_ESPTOOL_PY_AFTER) || "hard_reset";

    const flashMode = target.flashMode;
    const flashFreq = target.flashFreq;
    const flashSize = "detect";

    logImportant(`SPIFFS Uploading Image... (${spiffsImage})`);
    logSpiffs(`Python   : ${python}`);
    logSpiffs(`EspTool  : ${esptool}`);
    logSpiffs(`address  : ${uploadAddress}`);
    logSpiffs(`port     : ${commPort}`);
    logSpiffs(`speed    : ${uploadSpeed}`);
    logSpiffs(`before   : ${before}`);
    logSpiffs(`after    : ${after}`);
    logSpiffs(`flashMode: ${flashMode}`);
    logSpiffs(`flashFreq: ${flashFreq}`);
    logSpiffs(`flashSize: ${flashSize}`);

    const spi = getVscodeConfigValue(ESPFS_ESPTOOL_PY_SPI) || "";
    if (spi)
        logSpiffs(`SPI      : ${spi}`);

    let compress = getVscodeConfigValue(ESPFS_ESPTOOL_PY_COMPRESS);
    if (compress) {
        logSpiffs(`compress : ${compress}`);
        compress = compress == "true";
    } else
        compress = false;

    let args = [
        esptool,
        "--chip", target.architecture,
        "--baud", uploadSpeed,
        "--port", commPort,
        "--before", before,
        "--after", after
    ];

    if (getVscodeConfigValue(ESPFS_ESPTOOL_PY_NO_STUB) == "true")
        args.push("--no-stub");

    if (getVscodeConfigValue(ESPFS_ESPTOOL_PY_TRACE) == "true")
        args.push("--trace");

    args.push("write_flash");

    if (compress)
        args.push("--compress");

    args.push(
        "--flash_mode", flashMode,
        "--flash_freq", flashFreq,
        "--flash_size", flashSize
    );

    if (spi)
        args.push("--spi-connection", spi);

    if (getVscodeConfigValue(ESPFS_ESPTOOL_PY_VERIFY) == "true")
        args.push("--verify");

    args.push(uploadAddress, makeOsPath(spiffsImage));

    runCommand(makeOsPath(python), args);
}


function _uploadLittlefsEspToolPy(esptool, commPort, littlefsImage, littlefsOptions, target) {

    const python = getPythonExecutable();
    const uploadAddress = `0x` + toHex(stringToInt(littlefsOptions.spiffs_start), 6);
    var uploadSpeed = "921600";
    if (littlefsOptions.speed) // != "undefined")
        uploadSpeed = stringToInt(littlefsOptions.speed);

    const resetMethod = littlefsOptions.resetmethod;
    const before = getVscodeConfigValue(ESPFS_ESPTOOL_PY_BEFORE) || "default_reset";
    const after = getVscodeConfigValue(ESPFS_ESPTOOL_PY_AFTER) || "hard_reset";
    // const flashMode = target.flashMode || "keep";
    // const flashFreq = target.flashFreq || "keep";
    // const flashSize = target.flashSize || "keep";
    const flashMode = "keep";
    const flashFreq = "keep";
    const flashSize = "detect";

    logImportant(`LITTLEFS Uploading Image... (${littlefsImage})`);
    logLittlefs(`Python   : ${python}`);
    logLittlefs(`EspTool  : ${esptool}`);
    logLittlefs(`address  : ${uploadAddress}`);
    logLittlefs(`port     : ${commPort}`);
    logLittlefs(`speed    : ${uploadSpeed}`);
    logLittlefs(`before   : ${before}`);
    logLittlefs(`after    : ${after}`);
    logLittlefs(`flashMode: ${flashMode}`);
    logLittlefs(`flashFreq: ${flashFreq}`);
    logLittlefs(`flashSize: ${flashSize}`);

    const spi = getVscodeConfigValue(ESPFS_ESPTOOL_PY_SPI) || "";
    if (spi)
        logLittlefs(`SPI      : ${spi}`);

    let compress = getVscodeConfigValue(ESPFS_ESPTOOL_PY_COMPRESS);
    if (compress) {
        logLittlefs(`compress : ${compress}`);
        compress = compress == "true";
    } else
        compress = false;

    let args = [
        esptool,
        "--chip", target.architecture,
        "--baud", uploadSpeed,
        "--port", commPort,
        "--before", before,
        "--after", after
    ];

    if (getVscodeConfigValue(ESPFS_ESPTOOL_PY_NO_STUB) == "true")
        args.push("--no-stub");

    if (getVscodeConfigValue(ESPFS_ESPTOOL_PY_TRACE) == "true")
        args.push("--trace");

    args.push("write_flash");

    if (compress)
        args.push("--compress");

    args.push(
        "--flash_mode", flashMode,
        "--flash_freq", flashFreq,
        "--flash_size", flashSize
    );

    if (spi)
        args.push("--spi-connection", spi);

    if (getVscodeConfigValue(ESPFS_ESPTOOL_PY_VERIFY) == "true")
        args.push("--verify");

    args.push(uploadAddress, makeOsPath(littlefsImage));

    runCommand(makeOsPath(python), args);
}

//------------------------------------------------------------------------------

// --chip auto,esp32,esp8266
// --baud <rate>
// --port <port>
// --before default_reset,no_reset
// --after hard_reset,soft_reset,no_reset
// --no_stub
// --trace
//  read_flash
// --flash_mode <mode>
// --flash_freq <freq>
// --flash_size <size>
// --spi_connection <spi>
// --verify

/*function _downloadSpiffsEspToolPy(esptool, commPort, spiffsImage, spiffsOptions, target) {
    log(`--- Downloading SPIFFS file with esptool.py ---`);

    const python = getPythonExecutable();

    const downloadAddress = `0x` + toHex(stringToInt(spiffsOptions.spiffs_start), 6);
    const uploadSpeed = stringToInt(spiffsOptions.speed);
    const resetMethod = spiffsOptions.resetmethod;

    const before = getVscodeConfigValue(ESPFS_ESPTOOL_PY_BEFORE) || "default_reset";
    const after = getVscodeConfigValue(ESPFS_ESPTOOL_PY_AFTER) || "hard_reset";

    const flashMode = target.flashMode;
    const flashFreq = target.flashFreq;
    const flashSize = target.flashSize || "detect";

    logImportant(`SPIFFS Uploading Image... (${spiffsImage})`);
    logSpiffs(`Python   : ${python}`);
    logSpiffs(`EspTool  : ${esptool}`);
    logSpiffs(`address  : ${downloadAddress}`);
    logSpiffs(`port     : ${commPort}`);
    logSpiffs(`speed    : ${uploadSpeed}`);
    logSpiffs(`before   : ${before}`);
    logSpiffs(`after    : ${after}`);
    logSpiffs(`flashMode: ${flashMode}`);
    logSpiffs(`flashFreq: ${flashFreq}`);
    logSpiffs(`flashSize: ${flashSize}`);

    const spi = getVscodeConfigValue(ESPFS_ESPTOOL_PY_SPI) || "";
    if (spi)
        logSpiffs(`SPI      : ${spi}`);

    let args = [
        esptool,
        "--chip", target.architecture,
        "--baud", uploadSpeed,
        "--port", commPort,
        "--before", before,
        "--after", after
    ];

    if (getVscodeConfigValue(ESPFS_ESPTOOL_PY_NO_STUB) == "true")
        args.push("--no-stub");

    if (getVscodeConfigValue(ESPFS_ESPTOOL_PY_TRACE) == "true")
        args.push("--trace");

    args.push("write_flash");

    args.push(
        "--flash_mode", flashMode,
        "--flash_freq", flashFreq,
        "--flash_size", flashSize
    );

    if (spi)
        args.push("--spi-connection", spi);

    args.push(downloadAddress, makeOsPath(spiffsImage));

    runCommand(makeOsPath(python), args);
}

function _downloadLittlefsEspToolPy(esptool, commPort, littlefsImage, littlefsOptions, target) {
    log(`--- Downloading LITTLEFS file with esptool.py ---`);

    const python = getPythonExecutable();

    const downloadAddress = `0x` + toHex(stringToInt(littlefsOptions.spiffs_start), 6);
    const uploadSpeed = stringToInt(littlefsOptions.speed);
    const resetMethod = littlefsOptions.resetmethod;

    const before = getVscodeConfigValue(ESPFS_ESPTOOL_PY_BEFORE) || "default_reset";
    const after = getVscodeConfigValue(ESPFS_ESPTOOL_PY_AFTER) || "hard_reset";

    const flashMode = target.flashMode;
    const flashFreq = target.flashFreq;
    const flashSize = target.flashSize || "detect";

    logImportant(`LITTLEFS Uploading Image... (${littlefsImage})`);
    logLittlefs(`Python   : ${python}`);
    logLittlefs(`EspTool  : ${esptool}`);
    logLittlefs(`address  : ${downloadAddress}`);
    logLittlefs(`port     : ${commPort}`);
    logLittlefs(`speed    : ${uploadSpeed}`);
    logLittlefs(`before   : ${before}`);
    logLittlefs(`after    : ${after}`);
    logLittlefs(`flashMode: ${flashMode}`);
    logLittlefs(`flashFreq: ${flashFreq}`);
    logLittlefs(`flashSize: ${flashSize}`);

    const spi = getVscodeConfigValue(ESPFS_ESPTOOL_PY_SPI) || "";
    if (spi)
        logLittlefs(`SPI      : ${spi}`);

    let args = [
        esptool,
        "--chip", target.architecture,
        "--baud", uploadSpeed,
        "--port", commPort,
        "--before", before,
        "--after", after
    ];

    if (getVscodeConfigValue(ESPFS_ESPTOOL_PY_NO_STUB) == "true")
        args.push("--no-stub");

    if (getVscodeConfigValue(ESPFS_ESPTOOL_PY_TRACE) == "true")
        args.push("--trace");

    args.push("write_flash");

    args.push(
        "--flash_mode", flashMode,
        "--flash_freq", flashFreq,
        "--flash_size", flashSize
    );

    if (spi)
        args.push("--spi-connection", spi);

    args.push(downloadAddress, makeOsPath(littlefsImage));

    runCommand(makeOsPath(python), args);
}*/

//------------------------------------------------------------------------------

function uploadSpiffsEspTool(esptool, commPort, spiffsImage, spiffsOptions, target) {
    if (esptool.match(/\.py$/))
        _uploadSpiffsEspToolPy(esptool, commPort, spiffsImage, spiffsOptions, target);
    else
        _uploadSpiffsEspTool(esptool, commPort, spiffsImage, spiffsOptions);
}

function uploadLittlefsEspTool(esptool, commPort, littlefsImage, littlefsOptions, target) {
    if (esptool.match(/\.py$/))
        _uploadLittlefsEspToolPy(esptool, commPort, littlefsImage, littlefsOptions, target);
    else
        _uploadLittlefsEspTool(esptool, commPort, littlefsImage, littlefsOptions);
}

//------------------------------------------------------------------------------
/*
function downloadSpiffsEspTool(esptool, commPort, spiffsImage, spiffsOptions, target) {
    if (!esptool.match(/\.py$/))
        throw `Downloading only available if using "esptool.py"`;

    _downloadSpiffsEspToolPy(esptool, commPort, spiffsImage, spiffsOptions, target);
}

function downloadLittlefsEspTool(esptool, commPort, littlefsImage, littlefsOptions, target) {
    if (!esptool.match(/\.py$/))
        throw `Downloading only available if using "esptool.py"`;

    _downloadLittlefsEspToolPy(esptool, commPort, littlefsImage, littlefsOptions, target);
}
*/
// #endregion

//==============================================================================
// #region ESPOTA.PY

// --ip <address>
// --port <port>         default: 8266
// --host_ip <address>   default: 0.0.0.0
// --host_port <port>    default: random(10000, 60000)
// --auth <password>
// --spiffs
// --debug
// --file <image>

function uploadSpiffsOta(espota, ip, spiffsImage) {
    log(`--- Uploading SPIFFS file via OTA ---`);

    let port = 8266;

    if (ip.indexOf(":") != -1)
        [ip, port] = ip.split(":");

    port = getVscodeConfigValue(ESPFS_ESPOTA_ESP_PORT) || port;

    let host = getVscodeConfigValue(ESPFS_ESPOTA_HOST_IP);
    let host_port = "";

    if (host.indexOf(":") != -1)
        [host, host_port] = host.split(":");

    host_port = getVscodeConfigValue(ESPFS_ESPOTA_HOST_PORT) || host_port;
    const python = program(getPythonExecutable());

    logImportant(`SPIFFS Uploading Image... (${spiffsImage})`);
    logSpiffs(`Python   : ${python}`);
    logSpiffs(`EspOTA   : ${espota}`);
    logSpiffs(`IP       : ${ip}`);
    logSpiffs(`Port     : ${port}`);
    logSpiffs(`Host IP  : ${host}`);
    logSpiffs(`Host Port: ${host_port}`);

    let args = [
        makeOsPath(espota),               // Python code
        "--ip", ip                    // IP address
    ];

    if (port)
        args.push("--port", port);

    if (host)
        args.push("--host_ip", host);

    if (host_port)
        args.push("--host_port", host_port);

    let auth = getVscodeConfigValue(ESPFS_ESPOTA_AUTH);

    if (auth)
        args.push("--auth", auth);

    if (getVscodeConfigValue(ESPFS_ESPOTA_DEBUG))
        args.push("--debug");

    args.push(
        "--spiffs",                       // Sending SPIFFS - do not FLASH!
        "--file", makeOsPath(spiffsImage)
    );

    runCommand(makeOsPath(python), args);
}

function uploadLittlefsOta(espota, ip, littlefsImage) {
    log(`--- Uploading LITTLEFS file via OTA ---`);

    let port = 8266;

    if (ip.indexOf(":") != -1)
        [ip, port] = ip.split(":");

    port = getVscodeConfigValue(ESPFS_ESPOTA_ESP_PORT) || port;

    let host = getVscodeConfigValue(ESPFS_ESPOTA_HOST_IP);
    let host_port = "";

    if (host.indexOf(":") != -1)
        [host, host_port] = host.split(":");

    host_port = getVscodeConfigValue(ESPFS_ESPOTA_HOST_PORT) || host_port;
    const python = program(getPythonExecutable());

    logImportant(`LITTLEFS Uploading Image... (${littlefsImage})`);
    logLittlefs(`Python   : ${python}`);
    logLittlefs(`EspOTA   : ${espota}`);
    logLittlefs(`IP       : ${ip}`);
    logLittlefs(`Port     : ${port}`);
    logLittlefs(`Host IP  : ${host}`);
    logLittlefs(`Host Port: ${host_port}`);

    let args = [
        makeOsPath(espota),               // Python code
        "--ip", ip                    // IP address
    ];

    if (port)
        args.push("--port", port);

    if (host)
        args.push("--host_ip", host);

    if (host_port)
        args.push("--host_port", host_port);

    let auth = getVscodeConfigValue(ESPFS_ESPOTA_AUTH);

    if (auth)
        args.push("--auth", auth);

    if (getVscodeConfigValue(ESPFS_ESPOTA_DEBUG))
        args.push("--debug");

    args.push(
        "--littlefs",                       // Sending LITTLEFS - do not FLASH!
        "--file", makeOsPath(littlefsImage)
    );

    runCommand(makeOsPath(python), args);
}

// #endregion

//==============================================================================
// #region VSCode Command Handlers

async function _executeSpiffs(command) {
    const arduinoJson = await getArduinoJson();
    const preferencesPath = await getPreferencesPath();
    const preferences = await getArduinoPreferences(preferencesPath);

    const target = getTarget(arduinoJson, preferences);

    const dataPath = getDataFilesPath(arduinoJson);
    const spiffsImage = getSpiffsImage();

    const arduinoUserPath = getArduinoUserPath();
    const espPackagePath = getEspPackagePath(arduinoUserPath, preferencesPath, target);
    const espToolsPath = getEspToolsPath(arduinoUserPath, preferencesPath, target);

    const spiffsOptions = getSpiffsOptions(espPackagePath, target, arduinoJson, preferences);

    const port = getPort(arduinoJson, preferences);

    const mkspiffs = getMkSpiffs(target, espToolsPath);

    // --- Ready to get down to business ---

    switch (command) {
        case "upload": {
            if (isIP(port))
                uploadSpiffsOta(getEspotaPy(espPackagePath), port, spiffsImage);
            else
                uploadSpiffsEspTool(getEspTool(target, espToolsPath), port, spiffsImage, spiffsOptions, target);

            break;
        }

        /*case "download": {
            if (isIP(port))
                throw `No OTA support for "download"`;

            downloadSpiffsEspTool(getEspTool(target, espToolsPath), port, spiffsImage, spiffsOptions, target);

            break;
        }*/

        case "pack":
            packSpiffs(mkspiffs, dataPath, spiffsOptions, spiffsImage);
            break;

        /*case "unpack":
            unpackSpiffs(mkspiffs, dataPath, spiffsOptions, spiffsImage);
            break;*/

        case "list":
            listSpiffs(mkspiffs, spiffsOptions, spiffsImage);
            break;
    }
}

async function _executeLittlefs(command) {
    const arduinoJson = await getArduinoJson();
    const preferencesPath = await getPreferencesPath();
    const preferences = await getArduinoPreferences(preferencesPath);

    const target = getTarget(arduinoJson, preferences);

    const dataPath = getDataFilesPath(arduinoJson);
    const littlefsImage = getLittlefsImage();

    const arduinoUserPath = getArduinoUserPath();
    const espPackagePath = getEspPackagePath(arduinoUserPath, preferencesPath, target);
    const espToolsPath = getEspToolsPath(arduinoUserPath, preferencesPath, target);

    const littlefsOptions = getLittlefsOptions(espPackagePath, target, arduinoJson, preferences);

    const port = getPort(arduinoJson, preferences);

    const mklittlefs = getMkLittlefs(target, espToolsPath);

    // --- Ready to get down to business ---

    switch (command) {
        case "upload": {
            if (isIP(port))
                uploadLittlefsOta(getEspotaPy(espPackagePath), port, littlefsImage);
            else
                uploadLittlefsEspTool(getEspTool(target, espToolsPath), port, littlefsImage, littlefsOptions, target);

            break;
        }

        /*case "download": {
            if (isIP(port))
                throw `No OTA support for "download"`;

            downloadLittlefsEspTool(getEspTool(target, espToolsPath), port, littlefsImage, littlefsOptions, target);

            break;
        }*/

        case "pack":
            packLittlefs(mklittlefs, dataPath, littlefsOptions, littlefsImage);
            break;

        /*case "unpack":
            unpackLittlefs(mklittlefs, dataPath, littlefsOptions, littlefsImage);
            break;*/

        case "list":
            listLittlefs(mklittlefs, littlefsOptions, littlefsImage);
            break;
    }
}

//------------------------------------------------------------------------------

var locked = null;

async function executeSpiffs(command) {
    if (locked) {
        showErrorMessage(`ESPFS already running "${locked}"!`);
        return;
    }

    logLevel = getVscodeConfigValue(ESPFS_LOGLEVEL) || logLevel;

    logAnnounce(`ESP8266 SPIFFS interface started: "${command}".`);
    locked = command;

    try {
        await _executeSpiffs(command);
        showInformationMessage(`ESPFS "${command}" completed!`);
    } catch (error) {
        logUrgent(error);
        showErrorMessage(error);
        locked = null;
    }

    logAnnounce(`ESP8266 SPIFFS interface finished.`);
    locked = null;
}

async function executeLittlefs(command) {
    if (locked) {
        showErrorMessage(`ESPFS already running "${locked}"!`);
        return;
    }

    logLevel = getVscodeConfigValue(ESPFS_LOGLEVEL) || logLevel;

    logAnnounce(`ESP8266 LITTLEFS interface started: "${command}".`);
    locked = command;

    try {
        await _executeLittlefs(command);
        showInformationMessage(`ESPFS "${command}" completed!`);
    } catch (error) {
        logUrgent(error);
        showErrorMessage(error);
        locked = null;
    }

    logAnnounce(`ESP8266 LITTLEFS interface finished.`);
    locked = null;
}

//------------------------------------------------------------------------------

async function activate(context) {
    outputChannel = vscode.window.createOutputChannel("ESPFS");
    logLevel = getVscodeConfigValue(ESPFS_LOGLEVEL) || "normal";
    logVerbose(`ESPFS is now active!`);

    context.subscriptions.push(vscode.commands.registerCommand('espfs.uploadSpiffs', () => { executeSpiffs("upload"); }));
    //context.subscriptions.push(vscode.commands.registerCommand('espfs.downloadSpiffs',  () => { executeSpiffs("download"); }));
    context.subscriptions.push(vscode.commands.registerCommand('espfs.packSpiffs', () => { executeSpiffs("pack"); }));
    //context.subscriptions.push(vscode.commands.registerCommand('espfs.unpackSpiffs',    () => { executeSpiffs("unpack"); }));
    context.subscriptions.push(vscode.commands.registerCommand('espfs.listSpiffs', () => { executeSpiffs("list"); }));
    context.subscriptions.push(vscode.commands.registerCommand('espfs.uploadLittlefs', () => { executeLittlefs("upload"); }));
    //context.subscriptions.push(vscode.commands.registerCommand('espfs.downloadLittlefs',  () => { executeLittlefs("download"); }));
    context.subscriptions.push(vscode.commands.registerCommand('espfs.packLittlefs', () => { executeLittlefs("pack"); }));
    //context.subscriptions.push(vscode.commands.registerCommand('espfs.unpackLittlefs',    () => { executeLittlefs("unpack"); }));
    context.subscriptions.push(vscode.commands.registerCommand('espfs.listLittlefs', () => { executeLittlefs("list"); }));
}

exports.activate = activate;

//------------------------------------------------------------------------------

function deactivate() { }

exports.deactivate = (() => { });

// #endregion
